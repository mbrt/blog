<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Engineering a chess match against my brother | mbrt blog</title>
<meta name=keywords content="chess,data-science"><meta name=description content="This is the story of me trying to win a game of chess against my brother. A
single freaking game. What&rsquo;s so special about it? Am I good at chess? Not at
all. Did I improve at my game in the process? Also no. Is it a story about &ldquo;the
journey rather than the destination&rdquo;? Not really. Did I at least have fun in
the process? Not so sure. This is the story of me trying to be unconventional
at probably the most studied game in existence and using my software
engineering background for something that probably doesn&rsquo;t need it."><meta name=author content="Michele Bertasi"><link rel=canonical href=https://blog.mbrt.dev/posts/chess-eng/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.mbrt.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.mbrt.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.mbrt.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.mbrt.dev/apple-touch-icon.png><link rel=mask-icon href=https://blog.mbrt.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.mbrt.dev/posts/chess-eng/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.mbrt.dev/posts/chess-eng/"><meta property="og:site_name" content="mbrt blog"><meta property="og:title" content="Engineering a chess match against my brother"><meta property="og:description" content="This is the story of me trying to win a game of chess against my brother. A single freaking game. What’s so special about it? Am I good at chess? Not at all. Did I improve at my game in the process? Also no. Is it a story about “the journey rather than the destination”? Not really. Did I at least have fun in the process? Not so sure. This is the story of me trying to be unconventional at probably the most studied game in existence and using my software engineering background for something that probably doesn’t need it."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-28T00:00:00+00:00"><meta property="article:modified_time" content="2021-05-28T00:00:00+00:00"><meta property="article:tag" content="Chess"><meta property="article:tag" content="Data-Science"><meta name=twitter:card content="summary"><meta name=twitter:title content="Engineering a chess match against my brother"><meta name=twitter:description content="This is the story of me trying to win a game of chess against my brother. A
single freaking game. What&rsquo;s so special about it? Am I good at chess? Not at
all. Did I improve at my game in the process? Also no. Is it a story about &ldquo;the
journey rather than the destination&rdquo;? Not really. Did I at least have fun in
the process? Not so sure. This is the story of me trying to be unconventional
at probably the most studied game in existence and using my software
engineering background for something that probably doesn&rsquo;t need it."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.mbrt.dev/posts/"},{"@type":"ListItem","position":2,"name":"Engineering a chess match against my brother","item":"https://blog.mbrt.dev/posts/chess-eng/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Engineering a chess match against my brother","name":"Engineering a chess match against my brother","description":"This is the story of me trying to win a game of chess against my brother. A single freaking game. What\u0026rsquo;s so special about it? Am I good at chess? Not at all. Did I improve at my game in the process? Also no. Is it a story about \u0026ldquo;the journey rather than the destination\u0026rdquo;? Not really. Did I at least have fun in the process? Not so sure. This is the story of me trying to be unconventional at probably the most studied game in existence and using my software engineering background for something that probably doesn\u0026rsquo;t need it.\n","keywords":["chess","data-science"],"articleBody":"This is the story of me trying to win a game of chess against my brother. A single freaking game. What’s so special about it? Am I good at chess? Not at all. Did I improve at my game in the process? Also no. Is it a story about “the journey rather than the destination”? Not really. Did I at least have fun in the process? Not so sure. This is the story of me trying to be unconventional at probably the most studied game in existence and using my software engineering background for something that probably doesn’t need it.\nAlthough I’m a total disaster at chess and this post is useless to whoever seriously wants to improve at their game, I still think it was worth sharing how it’s possible to apply software engineering principles to a problem. Was I successful? You’ll see at the end.\nIntro: why I got into chess During the 2020 COVID19 pandemic, my brother, along with many other people, took a passion for playing online chess. After playing for a couple of months he started speaking very enthusiastically about it and challenging other family members, but where my father would budge (and get digitally butchered) I wouldn’t. For one thing, I refrained myself from delving into a potentially very time consuming hobby. I knew enough about chess to understand that to become even a mediocre amateur club player you’d still need to sink hundreds if not thousands of hours in the game. I admit I also didn’t like the thought of losing against my brother, which was certain at the time, since he already had hundreds of games under his belt and I had none.\nOne day I finally gave in and accepted a challenge from him. Needless to say that I lost completely. I knew the rules and the rudimentary of the game, having played a little bit as a kid, but my brother was obviously no match. Looking at the post-game analysis in chess.com I saw that my disadvantage only grew, move by move, until reaching a +9 evaluation (equivalent to having lost one rook, a bishop and a pawn to zero), which is beyond any hope for a comeback, where I resigned. This blueprint was followed during another couple of matches, where I understood I had to do something to avoid being demolished every time.\nThis was when I decided I wanted to study the game a bit more.\nFirst attempt: learn My first attempt in trying to improve at the game was to do the obvious: head to Reddit and YouTube to see what other learners recommended. Between a tutorial from GM Naroditsky, some reading and puzzle solving on Lichess, I also played a few games with random people on the Internet. My rating stayed pretty low nevertheless (1300 - 1400 Rapid on Lichess).\nAfter another couple of lost matches against my brother, it dawned on me that I had no hope of beating him. I was following his same steps to improve (playing, studying the game, watching videos), but I was dedicating much less time. At that point he was playing hundreds of games a month and I was willing to play maybe 10. At that pace I was only going to get further and further behind.\nIt was at that point that I had my second realization: I didn’t really care about the game, I didn’t want to really improve at chess in general, I only cared about beating a single person: my brother.\nSecond attempt: study the opponent A chess match can be generally divided into three phases: the opening, the middlegame and the endgame. Converting a significant advantage into a victory during an endgame is usually “easy”, after studying some basic checkmate patterns, so the question for me was how to get that advantage in the first place. Gaining advantage during a middlegame is usually achieved by long-term strategy and tactics. The first can be improved by reading and studying the game principles (something I can enjoy) while the second is only possible by doing puzzles (which I don’t particularly like doing). I knew that I would be at a disadvantage here, given that my brother used to do about 20 puzzles a day on chess.com, something I would never be able to catch up to. This only left one possibility: gaining advantage during the opening.\nChess opening theory is humongous and involves memorizing long sequences and variations of moves, along with possible replies from the opponent. Beginners don’t really need to memorize much, but some familiarity with the most common openings can go a long way (or so I was told). What I tried then was to look at some random games that my brother played and try to study the openings he was using. I looked at the Italian opening and Sicilian defense on Lichess and tried to memorize the basic ideas behind them. I also watched a bunch of videos on YouTube.\nObviously my brother had already done all of this before me (and better) and so I understandably lost again. Not to mention that memorizing meaningless (at least to me) opening moves is boring and laborious. I didn’t really have fun doing any of that. Another issue was that after my opponent deviated from the known book moves, I had no idea about how to react, because I didn’t really understand the positions.\nIt was time to step back and think again. I realized then I wasn’t really trying to beat my brother, but I was trying to improve my game against opponents that played his same openings perfectly. Could I be more specific? Could I prepare against my brother’s weaknesses instead? Obviously this wouldn’t work against any player other than him, but that still satisfied my goal.\nThird attempt: engineering The problem to solve became: find positions out of the opening that my brother (PlayerX from now on, for simplicity) would likely reach and be at a disadvantage. Remember that neither of us is an expert of the game and at our level players don’t play very accurately. The only way to play against a good player would be to follow book moves accurately, because you at least know in advance there’s no move they can make to gain an advantage. The story is different when you play against a club player. You can take risks (i.e. be temporarily at a disadvantage) if you know that your opponent is unlikely to be able to find the correct response and so get into trouble.\nI also had a list of over 500 games my brother played on chess.com. Being a software engineer, it came natural to me to approach this as any other engineering problem.\nI started by downloading the games he played by using the chess.com APIs and split them between black and white games. I focused on the games he played as black, given that I felt I had better chances at guiding the game where I wanted if I played as white.\nimport json import requests def get_month_games(player, yyyy_mm): url = 'https://api.chess.com/pub/player/{}/games/{}' r = requests.get(url.format(player, yyyy_mm)) if not r.ok: raise Exception('get_month_games failed') games = json.loads(r.content) # Format: {games: [{url, pgn}, ...]} return games['games'] # ... import chess.pgn import io import json with open('games.json') as f: data = json.load(f) games = [] for game in data: pgn = io.StringIO(game) games.append(chess.pgn.read_game(pgn)) black_games = [g for g in games if g.headers[\"Black\"] == \"playerx\"] Then I formulated the problem in this way: “Given all the positions PlayerX has seen, what are the ones that he’s likely to reach out of the opening where he is at a substantial disadvantage?”.\nNow I had a well formulated problem and I was finally playing in a domain I was familiar with. I decided to do my analysis in Python and in particular to use a Jupyter notebook, because I didn’t really want to create a reusable tool, but only to explore the available data and find one solution. It turns out Python already has pretty amazing libraries to manipulate chess games: python-chess (moves generation, validation, visualization) and python stockfish (bindings to evaluate a chess position by using the famous Stockfish chess engine).\nI translated the problem into a graph problem in this way: A node is a particular chess position (described in FEN notation). An edge links two nodes where the destination is reachable from the source position by doing a valid move. There’s a special initial node that is common to all games: the initial position.\nI then constructed the graph of all games played by PlayerX as black, additionally annotating every edge with the number of times the particular move was played.\nclass GamesGraph(): def __init__(self): self.graph = igraph.Graph(directed=True) def add_move(self, start_fen, end_fen, uci): vs = self._ensure_vertex(start_fen) vt = self._ensure_vertex(end_fen) try: e = self.graph.es.find(_source=vs.index, _target=vt.index) e[\"count\"] += 1 except: e = self.graph.add_edge(vs, vt) e[\"uci\"] = uci e[\"count\"] = 1 @property def start_node(self): return self.graph.vs.find(chess.STARTING_FEN) def _ensure_vertex(self, fen): try: return self.graph.vs.find(fen) except: v = self.graph.add_vertex(name=fen) v[\"fen\"] = fen v[\"turn\"] = chess.Board(fen).turn return v What results is weighted directed graph (not a tree because a position can be reached with different sequences of moves) similar to this one (a synthetic one because the real one would be too big to fit here):\nHere the initial position is the squared node, the color indicates whether from that position it’s black or white’s turn.\nI also wanted an evaluation of each position in terms of advantage for white and to do so I used Stockfish. Given that the process of evaluating thousands of positions is somewhat time consuming, I decided to do that separately and create a JSON object mapping each unique FEN position to its Stockfish evaluation.\nfrom stockfish import Stockfish stock = Stockfish(parameters={\"Threads\": 8}) stock.set_depth(20) stock.set_skill_level(20) def eval_pos(fen): stock.set_fen_position(fen) return stock.get_evaluation() # fens is a map between a FEN string and a node of the graph. for fen, node in graph.fens.items(): node.eva = eval_pos(fen) The evaluation is returned in centipawn advantage or “mate-in X moves”, where a positive number means advantage for white and negative is an advantage for black:\n{\"type\":\"cp\", \"value\":12} # 12 centipawns advantage for white. {\"type\":\"mate\", \"value\":-3} # Black has mate in three. 100 centipawns represent the advantage of having one more pawn than your opponent and 300 is a minor piece like a bishop. Note however that Stockfish assigns a value to pieces depending on their position, so it’s entirely possible to have an advantage of 1000 even if the pieces on the board are equal.\nI needed to map this evaluation into something more manageable, like a number between 0 and 1. To do so, I decided arbitrarily that an advantage of 300+ is mapped to 1.0 and a disadvantage of 300+ is mapped to 0. Additionally, any mate in X (even if X is 20) is 1 or 0.\n# Returns [-1;1] def rating(ev, fen): val = ev[\"value\"] if ev[\"type\"] == \"cp\": # Clamp to -300, +300. Winning a piece is enough. val = max(-300, min(300, val)) return val / 300.0 # Mate in X: also max rating. if val \u003e 0: return 1.0 if val \u003c 0: return -1.0 # This is already mate, but is it for white or black? b = chess.Board(fen) return 1.0 if b.turn == chess.WHITE else -1.0 # Returns [0;1], where 0 is min, 1 is max advantage for black. def rating_black(ev, fen): return -rating(ev, fen) * 0.5 + 0.5 The information was then all there, I just needed to find nodes in the graph (i.e. positions) where black was at a disadvantage, along with the sequence of moves that was most likely to reach it. I needed to weigh the edges in such a way that it was possible to easily compute the probability to reach a certain position. My reasoning was as follow:\nAt every position, we can evaluate the probability of doing a certain move by dividing the number of times the corresponding edge was taken by the total number of moves done from that position. Every edge will now have a weight between 0 and 1, where the higher the number, the higher the probability the edge will be taken from that position. The probability of a certain path is then the product of the probability of all the traversed edges. To solve the problem with standard graph algorithms I needed to transform the weights at the edges in such a way that:\nThey represent a distance instead of a probability (i.e. the longer the distance, the lower the probability of the path). The distance between two nodes is the sum of the weights of the traversed edges (as opposed to the product of probabilities). This is actually easier to do than to explain. The actual formula is very simple:\ndistance(e) = -log(prob(e)) Or, in Python:\ndef compute_edges_weight(vertex): all_count = sum(map(lambda x: x[\"count\"], vertex.out_edges())) for edge in vertex.out_edges(): prob = edge[\"count\"] / all_count edge[\"prob\"] = prob edge[\"weight\"] = -math.log(prob) Taking the logarithm of the probability of an edge will give a negative number, because the probability is between 0 and 1. We don’t have to worry about the case of probability zero (which would shoot the logarithm to minus infinity), as every edge of the graph has been taken at least once. The lower the probability, the more negative the logarithm will be, so inverting its sign will make it satisfy our requirements, because:\nThe sum of logarithms is the same as the logarithm of the product of their arguments: log(a) + log(b) = log(a*b). The bigger the result, the lower the underlying probability. Equipped with this data, we can compute the shortest path between the initial node and all other nodes by using Dijkstra’s algorithm. The result is a mapping between every node and the shortest path to the initial position, which represents the sequence of moves most likely to land in that position.\nAt that point I arbitrarily chose a minimum advantage and sorted the paths by probability. The first few paths represented my best chances to gain an advantage out of the opening against PlayerX.\nTweaks What did I find? This was a position returned by the algorithm above (white to move):\nAs you can see the situation for black is pretty bad (+8.9 according to Stockfish), because g6, the last move for black, was a mistake. White will go on, take the e5 pawn and the rook. The game for black is pretty much over, as they scramble to save the knight, the h7 pawn and the bishop. Another result was this one (white to move):\nWhich is mate in one move (Scholar’s mate).\nThe problem here is that these were mistakes done several times by PlayerX only during his first matches and never repeated again. Early queen attacks are usually carried out by very inexperienced players and they are effective only against players at that level. PlayerX hasn’t fallen for that trap for a long time afterwards, because better opponents don’t play that kind of move! I knew that I couldn’t really use this opening, because PlayerX knew how to defend against it now and would not fall for it anymore.\nAnother problem was related to sequences of moves that happened only once, but coming from common positions. The probability of the final position was the same as the probability of the last common position, because every edge had a probability of 1.0 (given that no other possibilities have been played). In the example below (edges marked with their probabilities), you can follow the edges with 7 and 6 (the most common position at move 2), but then follow one of the edges with a 1. From that point on, all the subsequent moves will have been played only once (because only a single match reached that position) and so every step will have a probability of 1.0.\nAnd this is how the probabilities look like:\nThis is intuitively incorrect, as it’s improbable that the same exact sequence of moves will be played with absolute certainty. We don’t have enough games being played from those positions to know that.\nThe famous quote (from Brewster?) “In theory there is no difference between theory and practice, while in practice there is”, was true in this case as well, so I needed a few tweaks and manual inspection to find better candidate positions.\nTo correct the second problem I decided to put an upper bound to the probability of an edge, so long sequences of moves played only once will gradually lose probability.\ndef compute_edges_weight(vertex, prob_ceiling=0.9): all_count = sum(map(lambda x: x[\"count\"], vertex.out_edges())) for edge in vertex.out_edges(): # Certainty doesn't exist... Let's put a probability ceiling (default 90%). prob = min(edge[\"count\"] / all_count, prob_ceiling) edge[\"prob\"] = prob edge[\"weight\"] = -math.log(prob) For the first problem I just manually screened out bad suggestions. At the end of the day I only needed one or two good positions to work on.\nOne more tweak was related to the fact that I didn’t want white’s probabilities to affect the probability of the paths, because I was playing white and could decide which path to take. For that reason I set all whites probabilities to 1.0 (a zero weight). The end result was a graph like this one:\nPreparation The position I settled on studying was this one:\nAccording to Lichess this is an Alekhine defense (two pawn attack). In this position there’s only one good move for black (Nb6) and black is still at a slight disadvantage (+0.6 according to Stockfish). However, from that position PlayerX often plays Nf4, which is bad (+2.3). I created a study in Lichess and started looking at several variations (good moves and moves played by PlayerX). The end result was a tree of possibilities that I tried to memorize and understand. For example I needed to know what a move like d5 was threatening, why the move Nf4 was bad and prepare the best responses.\nI didn’t spend much time doing this because I got bored pretty quickly, but I did prepare a bit for the upcoming match.\nThe match As if I were predicting the future, in my match against PlayerX, we got into an Alekhine defense. Put under pressure he did end up blundering his knight at move 5. Turns out even players much better than you end up making one mistake after another when they are at a disadvantage. It’s easy to play accurately when you’re winning, but can you keep your cool when you are losing? At move 10 I was at a +7.1 advantage, pretty much impossible to lose, but I was also out of my preparation. Look at how cramped black’s position is and how my pieces are all pointing towards the enemy’s king:\nI started making a bunch of mistakes from that point on, but I nevertheless was able to keep a non trivial advantage until move 27:\nUnfortunately I was very low on time (it was a rapid 10 minutes game) and so I had to move quickly. I ended up messing up completely move 32 and 33, giving my half-dead opponent mate in one :/.\nHere’s the full match (blunders and all):1\nConclusion What did I learn from this endeavour? A few things, most of which seem obvious in retrospect:\nPreparing for a specific opponent can give a considerable edge in the opening. Players at lower levels aren’t good at punishing dubious moves from the opponent. Getting into tricky positions where only one response is correct are easy ways to gain an advantage. The opening isn’t everything. If you are bad at time management and tactics, it’s possible to lose completely winning positions. Chess games can be decided by one bad move. Studying the game is important and there’s no silver bullet if your opponent is much better than you, but narrowing the skill gap is possible with specific preparation. Applying software engineering principles to chess is fun. Doing it to have a chance at beating your brother is even more fun! I hope I’ll be able to do it one day :) You can find the code I used in my GitHub repo. Note that I did not include the data and the code is quite messy, but I hope it can be of some inspiration, especially for folks that are considering whether computer science might be for them or not. Look, you can solve “real world” problems with it, it’s not just moving bits around!\nThat’s all folks, I hope I’ll be able to win a match against my brother some day, but until then, I’ll keep trying… my own way.\nFeedback on Hacker News.\nOriginal usernames are edited out because I didn’t ask my brother’s permission to post the match. I also still hope to try this trick one more time on him before he finds out :) ↩︎\n","wordCount":"3473","inLanguage":"en","datePublished":"2021-05-28T00:00:00Z","dateModified":"2021-05-28T00:00:00Z","author":{"@type":"Person","name":"Michele Bertasi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.mbrt.dev/posts/chess-eng/"},"publisher":{"@type":"Organization","name":"mbrt blog","logo":{"@type":"ImageObject","url":"https://blog.mbrt.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.mbrt.dev/ accesskey=h title="mbrt blog (Alt + H)">mbrt blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.mbrt.dev/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://blog.mbrt.dev/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.mbrt.dev/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.mbrt.dev/>Home</a>&nbsp;»&nbsp;<a href=https://blog.mbrt.dev/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Engineering a chess match against my brother</h1><div class=post-meta><span title='2021-05-28 00:00:00 +0000 UTC'>May 28, 2021</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;Michele Bertasi</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#intro-why-i-got-into-chess aria-label="Intro: why I got into chess">Intro: why I got into chess</a></li><li><a href=#first-attempt-learn aria-label="First attempt: learn">First attempt: learn</a></li><li><a href=#second-attempt-study-the-opponent aria-label="Second attempt: study the opponent">Second attempt: study the opponent</a></li><li><a href=#third-attempt-engineering aria-label="Third attempt: engineering">Third attempt: engineering</a><ul><li><a href=#tweaks aria-label=Tweaks>Tweaks</a></li><li><a href=#preparation aria-label=Preparation>Preparation</a></li></ul></li><li><a href=#the-match aria-label="The match">The match</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><p>This is the story of me trying to win a game of chess against my brother. A
single freaking game. What&rsquo;s so special about it? Am I good at chess? Not at
all. Did I improve at my game in the process? Also no. Is it a story about &ldquo;the
journey rather than the destination&rdquo;? Not really. Did I at least have fun in
the process? Not so sure. This is the story of me trying to be unconventional
at probably the most studied game in existence and using my software
engineering background for something that probably doesn&rsquo;t need it.</p><p>Although I&rsquo;m a total disaster at chess and this post is useless to whoever
seriously wants to improve at their game, I still think it was worth sharing
how it&rsquo;s possible to apply software engineering principles to a problem. Was I
successful? You&rsquo;ll see at the end.</p><h2 id=intro-why-i-got-into-chess>Intro: why I got into chess<a hidden class=anchor aria-hidden=true href=#intro-why-i-got-into-chess>#</a></h2><p>During the 2020 COVID19 pandemic, my brother, along with many other people,
took a passion for playing online chess. After playing for a couple of months
he started speaking very enthusiastically about it and challenging other family
members, but where my father would budge (and get digitally butchered) I
wouldn&rsquo;t. For one thing, I refrained myself from delving into a potentially
very time consuming hobby. I knew enough about chess to understand that to
become even a mediocre amateur club player you&rsquo;d still need to sink hundreds if
not thousands of hours in the game. I admit I also didn&rsquo;t like the thought of
losing against my brother, which was certain at the time, since he already had
hundreds of games under his belt and I had none.</p><p>One day I finally gave in and accepted a challenge from him. Needless to say
that I lost completely. I knew the rules and the rudimentary of the game,
having played a little bit as a kid, but my brother was obviously no match.
Looking at the post-game analysis in <a href=https://www.chess.com>chess.com</a> I saw
that my disadvantage only grew, move by move, until reaching a +9 evaluation
(equivalent to having lost one rook, a bishop and a pawn to zero), which is
beyond any hope for a comeback, where I resigned. This blueprint was followed
during another couple of matches, where I understood I had to do something to
avoid being demolished every time.</p><p>This was when I decided I wanted to study the game a bit more.</p><h2 id=first-attempt-learn>First attempt: learn<a hidden class=anchor aria-hidden=true href=#first-attempt-learn>#</a></h2><p>My first attempt in trying to improve at the game was to do the obvious: head
to Reddit and YouTube to see what other learners recommended. Between a
tutorial from
<a href=https://www.youtube.com/channel/UCHP9CdeguNUI-_nBv_UXBhw>GM Naroditsky</a>, some
reading and puzzle solving on <a href=https://lichess.org>Lichess</a>, I also played a
few games with random people on the Internet. My rating stayed pretty low
nevertheless (1300 - 1400 Rapid on Lichess).</p><p><img alt="Rating distribution" loading=lazy src=/posts/chess-eng/rating-distr.png></p><p>After another couple of lost matches against my brother, it dawned on me that I
had no hope of beating him. I was following his same steps to improve (playing,
studying the game, watching videos), but I was dedicating much less time. At
that point he was playing hundreds of games a month and I was willing to play
maybe 10. At that pace I was only going to get further and further behind.</p><p>It was at that point that I had my second realization: I didn&rsquo;t really care
about the game, I didn&rsquo;t want to really improve at chess in general, I only
cared about beating a single person: my brother.</p><h2 id=second-attempt-study-the-opponent>Second attempt: study the opponent<a hidden class=anchor aria-hidden=true href=#second-attempt-study-the-opponent>#</a></h2><p>A chess match can be generally divided into three phases: the
<a href=https://en.wikipedia.org/wiki/Chess_opening>opening</a>, the
<a href=https://en.wikipedia.org/wiki/Chess_middlegame>middlegame</a> and the
<a href=https://en.wikipedia.org/wiki/Chess_endgame>endgame</a>. Converting a
significant advantage into a victory during an endgame is usually &ldquo;easy&rdquo;, after
studying some
<a href=https://en.wikipedia.org/wiki/Checkmate#Basic_checkmates>basic checkmate patterns</a>,
so the question for me was how to get that advantage in the first place.
Gaining advantage during a middlegame is usually achieved by long-term
<a href=https://en.wikipedia.org/wiki/Chess_strategy>strategy</a> and
<a href=https://en.wikipedia.org/wiki/Chess_tactic>tactics</a>. The first can be
improved by reading and studying the game principles (something I can enjoy)
while the second is only possible by doing
<a href=https://en.wikipedia.org/wiki/Chess_puzzle>puzzles</a> (which I don&rsquo;t
particularly like doing). I knew that I would be at a disadvantage here, given
that my brother used to do about 20 puzzles a day on chess.com, something I
would never be able to catch up to. This only left one possibility: gaining
advantage during the opening.</p><p>Chess opening theory is humongous and involves memorizing long sequences and
variations of moves, along with possible replies from the opponent. Beginners
don&rsquo;t really need to memorize much, but some familiarity with the most common
openings can go a long way (or so I was told). What I tried then was to look at
some random games that my brother played and try to study the openings he was
using. I looked at the <a href=https://lichess.org/study/vJsZScnC>Italian opening</a>
and <a href=https://lichess.org/study/jsSks17H>Sicilian defense</a> on Lichess and tried
to memorize the basic ideas behind them. I also watched a bunch of videos on
YouTube.</p><p>Obviously my brother had already done all of this before me (and better) and so
I understandably lost again. Not to mention that memorizing meaningless (at
least to me) opening moves is boring and laborious. I didn&rsquo;t really have fun
doing any of that. Another issue was that after my opponent deviated from the
known book moves, I had no idea about how to react, because I didn&rsquo;t really
understand the positions.</p><p>It was time to step back and think again. I realized then I wasn&rsquo;t really
trying to beat my brother, but I was trying to improve my game against
opponents that played his same openings perfectly. Could I be more specific?
Could I prepare against my brother&rsquo;s weaknesses instead? Obviously this
wouldn&rsquo;t work against any player other than him, but that still satisfied my
goal.</p><h2 id=third-attempt-engineering>Third attempt: engineering<a hidden class=anchor aria-hidden=true href=#third-attempt-engineering>#</a></h2><p>The problem to solve became: find positions out of the opening that my brother
(PlayerX from now on, for simplicity) would likely reach and be at a
disadvantage. Remember that neither of us is an expert of the game and at our
level players don&rsquo;t play very accurately. The only way to play against a good
player would be to follow book moves accurately, because you at least know in
advance there&rsquo;s no move they can make to gain an advantage. The story is
different when you play against a club player. You can take risks (i.e. be
temporarily at a disadvantage) if you know that your opponent is unlikely to be
able to find the correct response and so get into trouble.</p><p>I also had a list of over 500 games my brother played on chess.com. Being a
software engineer, it came natural to me to approach this as any other
engineering problem.</p><p>I started by downloading the games he played by using the
<a href=https://www.chess.com/news/view/published-data-api>chess.com APIs</a> and split
them between black and white games. I focused on the games he played as black,
given that I felt I had better chances at guiding the game where I wanted if I
played as white.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>import</span> json
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> requests
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>get_month_games</span>(player, yyyy_mm):
</span></span><span style=display:flex><span>    url <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#39;https://api.chess.com/pub/player/</span><span style=color:#f1fa8c>{}</span><span style=color:#f1fa8c>/games/</span><span style=color:#f1fa8c>{}</span><span style=color:#f1fa8c>&#39;</span>
</span></span><span style=display:flex><span>    r <span style=color:#ff79c6>=</span> requests<span style=color:#ff79c6>.</span>get(url<span style=color:#ff79c6>.</span>format(player, yyyy_mm))
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>not</span> r<span style=color:#ff79c6>.</span>ok:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>raise</span> Exception(<span style=color:#f1fa8c>&#39;get_month_games failed&#39;</span>)
</span></span><span style=display:flex><span>    games <span style=color:#ff79c6>=</span> json<span style=color:#ff79c6>.</span>loads(r<span style=color:#ff79c6>.</span>content)
</span></span><span style=display:flex><span>    <span style=color:#6272a4># Format: {games: [{url, pgn}, ...]}</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> games[<span style=color:#f1fa8c>&#39;games&#39;</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># ...</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>import</span> chess.pgn
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> io
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> json
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>with</span> <span style=color:#8be9fd;font-style:italic>open</span>(<span style=color:#f1fa8c>&#39;games.json&#39;</span>) <span style=color:#ff79c6>as</span> f:
</span></span><span style=display:flex><span>    data <span style=color:#ff79c6>=</span> json<span style=color:#ff79c6>.</span>load(f)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>games <span style=color:#ff79c6>=</span> []
</span></span><span style=display:flex><span><span style=color:#ff79c6>for</span> game <span style=color:#ff79c6>in</span> data:
</span></span><span style=display:flex><span>    pgn <span style=color:#ff79c6>=</span> io<span style=color:#ff79c6>.</span>StringIO(game)
</span></span><span style=display:flex><span>    games<span style=color:#ff79c6>.</span>append(chess<span style=color:#ff79c6>.</span>pgn<span style=color:#ff79c6>.</span>read_game(pgn))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>black_games <span style=color:#ff79c6>=</span> [g <span style=color:#ff79c6>for</span> g <span style=color:#ff79c6>in</span> games <span style=color:#ff79c6>if</span> g<span style=color:#ff79c6>.</span>headers[<span style=color:#f1fa8c>&#34;Black&#34;</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#34;playerx&#34;</span>]
</span></span></code></pre></div><p>Then I formulated the problem in this way: &ldquo;Given all the positions PlayerX has
seen, what are the ones that he&rsquo;s likely to reach out of the opening where he
is at a substantial disadvantage?&rdquo;.</p><p>Now I had a well formulated problem and I was finally playing in a domain I was
familiar with. I decided to do my analysis in Python and in particular to use a
<a href=https://jupyter.org/>Jupyter notebook</a>, because I didn&rsquo;t really want to
create a reusable tool, but only to explore the available data and find <em>one</em>
solution. It turns out Python already has pretty amazing libraries to
manipulate chess games: <a href=https://python-chess.readthedocs.io/>python-chess</a>
(moves generation, validation, visualization) and
<a href=https://pypi.org/project/stockfish/>python stockfish</a> (bindings to evaluate a
chess position by using the famous Stockfish chess engine).</p><p>I translated the problem into a graph problem in this way: A node is a
particular chess position (described in
<a href=https://en.wikipedia.org/wiki/Forsyth%E2%80%93Edwards_Notation>FEN notation</a>).
An edge links two nodes where the destination is reachable from the source
position by doing a valid move. There&rsquo;s a special initial node that is common
to all games: the initial position.</p><p>I then constructed the graph of all games played by PlayerX as black,
additionally annotating every edge with the number of times the particular move
was played.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>GamesGraph</span>():
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>def</span> __init__(self):
</span></span><span style=display:flex><span>        self<span style=color:#ff79c6>.</span>graph <span style=color:#ff79c6>=</span> igraph<span style=color:#ff79c6>.</span>Graph(directed<span style=color:#ff79c6>=</span><span style=color:#ff79c6>True</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>add_move</span>(self, start_fen, end_fen, uci):
</span></span><span style=display:flex><span>        vs <span style=color:#ff79c6>=</span> self<span style=color:#ff79c6>.</span>_ensure_vertex(start_fen)
</span></span><span style=display:flex><span>        vt <span style=color:#ff79c6>=</span> self<span style=color:#ff79c6>.</span>_ensure_vertex(end_fen)
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>try</span>:
</span></span><span style=display:flex><span>            e <span style=color:#ff79c6>=</span> self<span style=color:#ff79c6>.</span>graph<span style=color:#ff79c6>.</span>es<span style=color:#ff79c6>.</span>find(_source<span style=color:#ff79c6>=</span>vs<span style=color:#ff79c6>.</span>index, _target<span style=color:#ff79c6>=</span>vt<span style=color:#ff79c6>.</span>index)
</span></span><span style=display:flex><span>            e[<span style=color:#f1fa8c>&#34;count&#34;</span>] <span style=color:#ff79c6>+=</span> <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>except</span>:
</span></span><span style=display:flex><span>            e <span style=color:#ff79c6>=</span> self<span style=color:#ff79c6>.</span>graph<span style=color:#ff79c6>.</span>add_edge(vs, vt)
</span></span><span style=display:flex><span>            e[<span style=color:#f1fa8c>&#34;uci&#34;</span>] <span style=color:#ff79c6>=</span> uci
</span></span><span style=display:flex><span>            e[<span style=color:#f1fa8c>&#34;count&#34;</span>] <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    @property
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>start_node</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> self<span style=color:#ff79c6>.</span>graph<span style=color:#ff79c6>.</span>vs<span style=color:#ff79c6>.</span>find(chess<span style=color:#ff79c6>.</span>STARTING_FEN)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>_ensure_vertex</span>(self, fen):
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>try</span>:
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> self<span style=color:#ff79c6>.</span>graph<span style=color:#ff79c6>.</span>vs<span style=color:#ff79c6>.</span>find(fen)
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>except</span>:
</span></span><span style=display:flex><span>            v <span style=color:#ff79c6>=</span> self<span style=color:#ff79c6>.</span>graph<span style=color:#ff79c6>.</span>add_vertex(name<span style=color:#ff79c6>=</span>fen)
</span></span><span style=display:flex><span>            v[<span style=color:#f1fa8c>&#34;fen&#34;</span>] <span style=color:#ff79c6>=</span> fen
</span></span><span style=display:flex><span>            v[<span style=color:#f1fa8c>&#34;turn&#34;</span>] <span style=color:#ff79c6>=</span> chess<span style=color:#ff79c6>.</span>Board(fen)<span style=color:#ff79c6>.</span>turn
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> v
</span></span></code></pre></div><p>What results is weighted directed graph (not a tree because a position can be
reached with different sequences of moves) similar to this one (a synthetic one
because the real one would be too big to fit here):</p><p><img alt="Graph with counters" loading=lazy src=/posts/chess-eng/graph-freq-eval.svg></p><p>Here the initial position is the squared node, the color indicates whether
from that position it&rsquo;s black or white&rsquo;s turn.</p><p>I also wanted an evaluation of each position in terms of advantage for white
and to do so I used Stockfish. Given that the process of evaluating thousands
of positions is somewhat time consuming, I decided to do that separately and
create a JSON object mapping each unique FEN position to its Stockfish
evaluation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>from</span> stockfish <span style=color:#ff79c6>import</span> Stockfish
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>stock <span style=color:#ff79c6>=</span> Stockfish(parameters<span style=color:#ff79c6>=</span>{<span style=color:#f1fa8c>&#34;Threads&#34;</span>: <span style=color:#bd93f9>8</span>})
</span></span><span style=display:flex><span>stock<span style=color:#ff79c6>.</span>set_depth(<span style=color:#bd93f9>20</span>)
</span></span><span style=display:flex><span>stock<span style=color:#ff79c6>.</span>set_skill_level(<span style=color:#bd93f9>20</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>eval_pos</span>(fen):
</span></span><span style=display:flex><span>    stock<span style=color:#ff79c6>.</span>set_fen_position(fen)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> stock<span style=color:#ff79c6>.</span>get_evaluation()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># fens is a map between a FEN string and a node of the graph.</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>for</span> fen, node <span style=color:#ff79c6>in</span> graph<span style=color:#ff79c6>.</span>fens<span style=color:#ff79c6>.</span>items():
</span></span><span style=display:flex><span>    node<span style=color:#ff79c6>.</span>eva <span style=color:#ff79c6>=</span> eval_pos(fen)
</span></span></code></pre></div><p>The evaluation is returned in
<a href=https://chess.fandom.com/wiki/Centipawn>centipawn advantage</a> or &ldquo;mate-in X
moves&rdquo;, where a positive number means advantage for white and negative is an
advantage for black:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>{<span style=color:#f1fa8c>&#34;type&#34;</span>:<span style=color:#f1fa8c>&#34;cp&#34;</span>, <span style=color:#f1fa8c>&#34;value&#34;</span>:<span style=color:#bd93f9>12</span>}    <span style=color:#6272a4># 12 centipawns advantage for white.</span>
</span></span><span style=display:flex><span>{<span style=color:#f1fa8c>&#34;type&#34;</span>:<span style=color:#f1fa8c>&#34;mate&#34;</span>, <span style=color:#f1fa8c>&#34;value&#34;</span>:<span style=color:#ff79c6>-</span><span style=color:#bd93f9>3</span>}  <span style=color:#6272a4># Black has mate in three.</span>
</span></span></code></pre></div><p>100 centipawns represent the advantage of having one more pawn than your
opponent and 300 is a minor piece like a bishop. Note however that Stockfish
assigns a value to pieces depending on their position, so it&rsquo;s entirely
possible to have an advantage of 1000 even if the pieces on the board are
equal.</p><p>I needed to map this evaluation into something more manageable, like a number
between 0 and 1. To do so, I decided arbitrarily that an advantage of 300+ is
mapped to 1.0 and a disadvantage of 300+ is mapped to 0. Additionally, any mate
in X (even if X is 20) is 1 or 0.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># Returns [-1;1]</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>rating</span>(ev, fen):
</span></span><span style=display:flex><span>    val <span style=color:#ff79c6>=</span> ev[<span style=color:#f1fa8c>&#34;value&#34;</span>]
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> ev[<span style=color:#f1fa8c>&#34;type&#34;</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#34;cp&#34;</span>:
</span></span><span style=display:flex><span>        <span style=color:#6272a4># Clamp to -300, +300. Winning a piece is enough.</span>
</span></span><span style=display:flex><span>        val <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>max</span>(<span style=color:#ff79c6>-</span><span style=color:#bd93f9>300</span>, <span style=color:#8be9fd;font-style:italic>min</span>(<span style=color:#bd93f9>300</span>, val))
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> val <span style=color:#ff79c6>/</span> <span style=color:#bd93f9>300.0</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># Mate in X: also max rating.</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> val <span style=color:#ff79c6>&gt;</span> <span style=color:#bd93f9>0</span>: <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>1.0</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> val <span style=color:#ff79c6>&lt;</span> <span style=color:#bd93f9>0</span>: <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>-</span><span style=color:#bd93f9>1.0</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># This is already mate, but is it for white or black?</span>
</span></span><span style=display:flex><span>    b <span style=color:#ff79c6>=</span> chess<span style=color:#ff79c6>.</span>Board(fen)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>1.0</span> <span style=color:#ff79c6>if</span> b<span style=color:#ff79c6>.</span>turn <span style=color:#ff79c6>==</span> chess<span style=color:#ff79c6>.</span>WHITE <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>-</span><span style=color:#bd93f9>1.0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># Returns [0;1], where 0 is min, 1 is max advantage for black.</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>rating_black</span>(ev, fen):
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>-</span>rating(ev, fen) <span style=color:#ff79c6>*</span> <span style=color:#bd93f9>0.5</span> <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>0.5</span>
</span></span></code></pre></div><p>The information was then all there, I just needed to find nodes in the graph
(i.e. positions) where black was at a disadvantage, along with the sequence of
moves that was most likely to reach it. I needed to weigh the edges in such a
way that it was possible to easily compute the probability to reach a certain
position. My reasoning was as follow:</p><ul><li>At every position, we can evaluate the probability of doing a certain move by
dividing the number of times the corresponding edge was taken by the total
number of moves done from that position.</li><li>Every edge will now have a weight between 0 and 1, where the higher the
number, the higher the probability the edge will be taken from that position.</li><li>The probability of a certain path is then the product of the probability of
all the traversed edges.</li></ul><p>To solve the problem with standard graph algorithms I needed to transform the
weights at the edges in such a way that:</p><ul><li>They represent a distance instead of a probability (i.e. the longer the
distance, the lower the probability of the path).</li><li>The distance between two nodes is the sum of the weights of the traversed
edges (as opposed to the product of probabilities).</li></ul><p>This is actually easier to do than to explain. The actual formula is very
simple:</p><pre tabindex=0><code>distance(e) = -log(prob(e))
</code></pre><p>Or, in Python:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>compute_edges_weight</span>(vertex):
</span></span><span style=display:flex><span>    all_count <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>sum</span>(<span style=color:#8be9fd;font-style:italic>map</span>(<span style=color:#ff79c6>lambda</span> x: x[<span style=color:#f1fa8c>&#34;count&#34;</span>], vertex<span style=color:#ff79c6>.</span>out_edges()))
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> edge <span style=color:#ff79c6>in</span> vertex<span style=color:#ff79c6>.</span>out_edges():
</span></span><span style=display:flex><span>        prob <span style=color:#ff79c6>=</span> edge[<span style=color:#f1fa8c>&#34;count&#34;</span>] <span style=color:#ff79c6>/</span> all_count
</span></span><span style=display:flex><span>        edge[<span style=color:#f1fa8c>&#34;prob&#34;</span>] <span style=color:#ff79c6>=</span> prob
</span></span><span style=display:flex><span>        edge[<span style=color:#f1fa8c>&#34;weight&#34;</span>] <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>-</span>math<span style=color:#ff79c6>.</span>log(prob)
</span></span></code></pre></div><p>Taking the logarithm of the probability of an edge will give a negative number,
because the probability is between 0 and 1. We don&rsquo;t have to worry about the
case of probability zero (which would shoot the logarithm to minus infinity),
as every edge of the graph has been taken at least once. The lower the
probability, the more negative the logarithm will be, so inverting its sign
will make it satisfy our requirements, because:</p><ul><li>The sum of logarithms is the same as the logarithm of the product of their
arguments: <code>log(a) + log(b) = log(a*b)</code>.</li><li>The bigger the result, the lower the underlying probability.</li></ul><p><img alt="graph with weights" loading=lazy src=/posts/chess-eng/graph-weights-simple.svg></p><p>Equipped with this data, we can compute the <a href=https://en.wikipedia.org/wiki/Shortest_path_problem>shortest
path</a> between the initial
node and all other nodes by using
<a href=https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm>Dijkstra&rsquo;s algorithm</a>.
The result is a mapping between every node and the shortest path to the initial
position, which represents the sequence of moves most likely to land in that
position.</p><p>At that point I arbitrarily chose a minimum advantage and sorted the paths by
probability. The first few paths represented my best chances to gain an
advantage out of the opening against PlayerX.</p><h3 id=tweaks>Tweaks<a hidden class=anchor aria-hidden=true href=#tweaks>#</a></h3><p>What did I find? This was a position returned by the algorithm above (white to
move):</p><p><img alt="early queen attack" loading=lazy src=/posts/chess-eng/early-queen-attack.svg></p><p>As you can see the situation for black is pretty bad (+8.9 according to
Stockfish), because g6, the last move for black, was a mistake. White will go
on, take the e5 pawn and the rook. The game for black is pretty much over, as
they scramble to save the knight, the h7 pawn and the bishop. Another result
was this one (white to move):</p><p><img alt="scholars mate" loading=lazy src=/posts/chess-eng/scholars-mate.svg></p><p>Which is mate in one move
(<a href=https://en.wikipedia.org/wiki/Scholar%27s_mate>Scholar&rsquo;s mate</a>).</p><p>The problem here is that these were mistakes done several times by PlayerX only
during his first matches and never repeated again. Early queen attacks are
usually carried out by very inexperienced players and they are effective only
against players at that level. PlayerX hasn&rsquo;t fallen for that trap for a long
time afterwards, because better opponents don&rsquo;t play that kind of move! I knew
that I couldn&rsquo;t really use this opening, because PlayerX knew how to defend
against it now and would not fall for it anymore.</p><p>Another problem was related to sequences of moves that happened only once, but
coming from common positions. The probability of the final position was the
same as the probability of the last common position, because every edge had a
probability of 1.0 (given that no other possibilities have been played). In the
example below (edges marked with their probabilities), you can follow the edges
with 7 and 6 (the most common position at move 2), but then follow one of the
edges with a 1. From that point on, all the subsequent moves will have been
played only once (because only a single match reached that position) and so
every step will have a probability of 1.0.</p><p><img alt="graph with frequencies" loading=lazy src=/posts/chess-eng/graph-freq-eval.svg></p><p>And this is how the probabilities look like:</p><p><img alt="graph with probabilities" loading=lazy src=/posts/chess-eng/graph-prob-simple.svg></p><p>This is intuitively incorrect, as it&rsquo;s improbable that the same exact sequence
of moves will be played with absolute certainty. We don&rsquo;t have enough games
being played from those positions to know that.</p><p>The famous quote
(<a href=https://quoteinvestigator.com/2018/04/14/theory/>from Brewster?</a>) &ldquo;In theory
there is no difference between theory and practice, while in practice there
is&rdquo;, was true in this case as well, so I needed a few tweaks and manual
inspection to find better candidate positions.</p><p>To correct the second problem I decided to put an upper bound to the
probability of an edge, so long sequences of moves played only once will
gradually lose probability.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>compute_edges_weight</span>(vertex, prob_ceiling<span style=color:#ff79c6>=</span><span style=color:#bd93f9>0.9</span>):
</span></span><span style=display:flex><span>    all_count <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>sum</span>(<span style=color:#8be9fd;font-style:italic>map</span>(<span style=color:#ff79c6>lambda</span> x: x[<span style=color:#f1fa8c>&#34;count&#34;</span>], vertex<span style=color:#ff79c6>.</span>out_edges()))
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> edge <span style=color:#ff79c6>in</span> vertex<span style=color:#ff79c6>.</span>out_edges():
</span></span><span style=display:flex><span>        <span style=color:#6272a4># Certainty doesn&#39;t exist... Let&#39;s put a probability ceiling (default 90%).</span>
</span></span><span style=display:flex><span>        prob <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>min</span>(edge[<span style=color:#f1fa8c>&#34;count&#34;</span>] <span style=color:#ff79c6>/</span> all_count, prob_ceiling)
</span></span><span style=display:flex><span>        edge[<span style=color:#f1fa8c>&#34;prob&#34;</span>] <span style=color:#ff79c6>=</span> prob
</span></span><span style=display:flex><span>        edge[<span style=color:#f1fa8c>&#34;weight&#34;</span>] <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>-</span>math<span style=color:#ff79c6>.</span>log(prob)
</span></span></code></pre></div><p>For the first problem I just manually screened out bad suggestions. At the end
of the day I only needed one or two good positions to work on.</p><p>One more tweak was related to the fact that I didn&rsquo;t want white&rsquo;s probabilities
to affect the probability of the paths, because I was playing white and could
decide which path to take. For that reason I set all whites probabilities to
1.0 (a zero weight). The end result was a graph like this one:</p><p><img alt="graph with weights final" loading=lazy src=/posts/chess-eng/graph-weights-final.svg></p><h3 id=preparation>Preparation<a hidden class=anchor aria-hidden=true href=#preparation>#</a></h3><p>The position I settled on studying was this one:</p><p><img alt=alekhine loading=lazy src=/posts/chess-eng/alekhine.svg></p><p>According to Lichess this is an Alekhine defense (two pawn attack). In this
position there&rsquo;s only one good move for black (Nb6) and black is still at a
slight disadvantage (+0.6 according to Stockfish). However, from that position
PlayerX often plays Nf4, which is bad (+2.3). I created a study in Lichess and
started looking at several variations (good moves and moves played by PlayerX).
The end result was a tree of possibilities that I tried to memorize and
understand. For example I needed to know what a move like d5 was threatening,
why the move Nf4 was bad and prepare the best responses.</p><p>I didn&rsquo;t spend much time doing this because I got bored pretty quickly, but I
did prepare a bit for the upcoming match.</p><h2 id=the-match>The match<a hidden class=anchor aria-hidden=true href=#the-match>#</a></h2><p>As if I were predicting the future, in my match against PlayerX, we got into an
Alekhine defense. Put under pressure he did end up blundering his knight at
move 5. Turns out even players much better than you end up making one mistake
after another when they are at a disadvantage. It&rsquo;s easy to play accurately
when you&rsquo;re winning, but can you keep your cool when you are losing? At move 10
I was at a +7.1 advantage, pretty much impossible to lose, but I was also out
of my preparation. Look at how cramped black&rsquo;s position is and how my pieces
are all pointing towards the enemy&rsquo;s king:</p><p><img alt="game opening" loading=lazy src=/posts/chess-eng/game-opening.svg></p><p>I started making a bunch of mistakes from that point on, but I nevertheless was
able to keep a non trivial advantage until move 27:</p><p><img alt="game mid" loading=lazy src=/posts/chess-eng/game-mid.svg></p><p>Unfortunately I was very low on time (it was a rapid 10 minutes game) and so I
had to move quickly. I ended up messing up completely move 32 and 33, giving my
half-dead opponent mate in one :/.</p><p><img alt="game end" loading=lazy src=/posts/chess-eng/game-end.svg></p><p>Here&rsquo;s the full match (blunders and all):<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><iframe src="https://lichess.org/embed/2qKKl2MI?theme=auto&bg=auto" width=600 height=397 frameborder=0></iframe><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>What did I learn from this endeavour? A few things, most of which seem obvious
in retrospect:</p><ol><li>Preparing for a specific opponent can give a considerable edge in the
opening.</li><li>Players at lower levels aren&rsquo;t good at punishing dubious moves from the
opponent. Getting into tricky positions where only one response is correct
are easy ways to gain an advantage.</li><li>The opening isn&rsquo;t everything. If you are bad at time management and tactics,
it&rsquo;s possible to lose completely winning positions. Chess games can be
decided by one bad move.</li><li>Studying the game is important and there&rsquo;s no silver bullet if your opponent
is much better than you, but narrowing the skill gap is possible with
specific preparation.</li><li>Applying software engineering principles to chess is fun. Doing it to have a
chance at beating your brother is even more fun! I hope I&rsquo;ll be able to do
it one day :)</li></ol><p>You can find the code I used in my
<a href=https://github.com/mbrt/chess-analysis>GitHub repo</a>. Note that I did not
include the data and the code is quite messy, but I hope it can be of some
inspiration, especially for folks that are considering whether computer science
might be for them or not. Look, you can solve &ldquo;real world&rdquo; problems with it,
it&rsquo;s not just moving bits around!</p><p>That&rsquo;s all folks, I hope I&rsquo;ll be able to win a match against my brother some
day, but until then, I&rsquo;ll keep trying&mldr; my own way.</p><p>Feedback on <a href="https://news.ycombinator.com/item?id=27431924">Hacker News</a>.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Original usernames are edited out because I didn&rsquo;t ask my brother&rsquo;s
permission to post the match. I also still hope to try this trick one more time
on him before he finds out :)&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.mbrt.dev/tags/chess/>Chess</a></li><li><a href=https://blog.mbrt.dev/tags/data-science/>Data-Science</a></li></ul><nav class=paginav><a class=prev href=https://blog.mbrt.dev/posts/no-need-sre/><span class=title>« Prev</span><br><span>Maybe you don't need SRE</span>
</a><a class=next href=https://blog.mbrt.dev/posts/container-network/><span class=title>Next »</span><br><span>Demystifying container networking</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Engineering a chess match against my brother on x" href="https://x.com/intent/tweet/?text=Engineering%20a%20chess%20match%20against%20my%20brother&amp;url=https%3a%2f%2fblog.mbrt.dev%2fposts%2fchess-eng%2f&amp;hashtags=chess%2cdata-science"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Engineering a chess match against my brother on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.mbrt.dev%2fposts%2fchess-eng%2f&amp;title=Engineering%20a%20chess%20match%20against%20my%20brother&amp;summary=Engineering%20a%20chess%20match%20against%20my%20brother&amp;source=https%3a%2f%2fblog.mbrt.dev%2fposts%2fchess-eng%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Engineering a chess match against my brother on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.mbrt.dev%2fposts%2fchess-eng%2f&title=Engineering%20a%20chess%20match%20against%20my%20brother"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Engineering a chess match against my brother on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.mbrt.dev%2fposts%2fchess-eng%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Engineering a chess match against my brother on whatsapp" href="https://api.whatsapp.com/send?text=Engineering%20a%20chess%20match%20against%20my%20brother%20-%20https%3a%2f%2fblog.mbrt.dev%2fposts%2fchess-eng%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Engineering a chess match against my brother on telegram" href="https://telegram.me/share/url?text=Engineering%20a%20chess%20match%20against%20my%20brother&amp;url=https%3a%2f%2fblog.mbrt.dev%2fposts%2fchess-eng%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Engineering a chess match against my brother on ycombinator" href="https://news.ycombinator.com/submitlink?t=Engineering%20a%20chess%20match%20against%20my%20brother&u=https%3a%2f%2fblog.mbrt.dev%2fposts%2fchess-eng%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.mbrt.dev/>mbrt blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>